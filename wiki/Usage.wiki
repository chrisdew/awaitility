= General =
Developers today need to depend heavily on concurrent programming, asynchronous and distributed systems to allow for scalability and performance. A typical example is a message based system that perform various tasks after having interpreted a message and its payload. It may write to an event log, update database state, send additional messages to remote systems etc, possibly everything in an asynchronous manner. These kind of systems are not always easy to test. For example you may want to verify that when an ADD_USER message is sent to a system a new user is persisted into a database. If something unexpected happens such as an exception being thrown in any thread you'd still like your test to fail indicating this error. Awaitility let's you test these systems easily.

= Usage examples =

==Example 1==
So let's assume that we send a "ADD_USER" message to our asynchronous system like this:

{{{
publish(new AddUserMessage("Awaitility Rocks"));
}}}

In your test case Awaitility can help you to easily verify that the database has been updated. In its simplest form it may look something like this:

{{{
await().until(newUserWasAdded());
}}}

`newUserWasAdded` is a method that you implement yourself in your test case. It specifies the condition that must be fulfilled in order for Awaitility to stop waiting.

{{{
private Callable<Boolean> newUserWasAdded() {
	return new Callable<Boolean>() {
		public Boolean call() throws Exception {
			return userRepository.size() == 1; // The condition that must be fulfilled
		}
	};
}
}}}

By default Awaitility will wait for 10 seconds and if the size of the user respository is not equal to 1 during this time it'll throw a <code>TimeoutException</code> failing the test. If you want a different timeout you can define it like this:

{{{
await().atMost(5, SECONDS).until(newUserWasAdded());
}}}

===Example 2===
Wait forever until the call to `orderService.orderCount()` is greater than 3.
{{{
await().forever().until(callTo(orderService).orderCount(), greaterThan(3));
}}}

===Example 3===
Use a poll interval of 100 milliseconds with an initial delay of 20 milliseconds until customer status is equal to "REGISTERED". This example also uses a named await by specifying an alias ("customer registration"). This makes it easy to find out which await statement that failed if you have multiple awaits in the same test.
{{{  
withPollInterval(ONE_HUNDERED_MILLISECONDS).andWithPollDelay(20, MILLISECONDS).await("customer registration").until(
  		costumerStatus(), equalTo(REGISTERED));
}}}  


== Defaults ==
If you don't specify any timeout Awaitility will wait for 10 seconds and then throw a <code>TimeoutException</code> if the condition has not been fulfilled. The default poll interval and poll delay is 100 milliseconds. You can also specify the default values yourself using:
  
{{{
  Awaitility.setDefaultTimeout(..)
  Awaitility.setDefaultPollInterval(..)
  Awaitility.setDefaultPollDelay(..)
}}}
  
You can also reset back to the default values using `Awaitility.reset()`.

== Static imports ==
In order to use Awaitility effectively it's recommended to statically import the following methods from the Awaitility framework:
  # `com.jayway.awaitility.Awaitlity.*`
It may also be useful to import these methods:
  # `com.jayway.awaitility.Duration.*`
  # `java.util.concurrent.TimeUnit.*`
  # `org.hamcrest.Matchers.*`
  # `org.junit.Assert.*`


== Polling == 
Awaitility starts to check the specified condition (the one you create using the Awaitility DSL) matches for the first time after a "poll delay" (the initial delay before the polling begins). By default Awaitility uses the same poll delay as poll interval which means that it checks the condition periodically first after the given poll delay, and subsequently with the given poll interval; that is conditions are checked after pollDelay then pollDelay+pollInterval, then pollDelay + 2 pollInterval, and so on.
<br/>
<br/>

If you change the poll interval the poll delay will also change to match the specified poll interval _unless_ you've specified a poll delay explicitly.
<br/>
<br/>
Note that since Awaitility uses polling to verify that a condition matches it's not recommended to use it for precise performance testing. In these cases it's better to use an AOP framework such as AspectJ's compile-time weaving.