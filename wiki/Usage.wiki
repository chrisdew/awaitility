For Scala documentation click [Scala here].

= Usage examples =

==Example 1 - Simple==
Let's assume that we send a "add user" message to our asynchronous system like this:

{{{
publish(new AddUserMessage("Awaitility Rocks"));
}}}

In your test case Awaitility can help you to easily verify that the database has been updated. In its simplest form it may look something like this:

{{{
await().until(newUserIsAdded());
}}}

`newUserIsAdded` is a method that you implement yourself in your test case. It specifies the condition that must be fulfilled in order for Awaitility to stop waiting.

{{{
private Callable<Boolean> newUserIsAdded() {
	return new Callable<Boolean>() {
		public Boolean call() throws Exception {
			return userRepository.size() == 1; // The condition that must be fulfilled
		}
	};
}
}}}

By default Awaitility will wait for 10 seconds and if the size of the user respository is not equal to 1 during this time it'll throw a `TimeoutException` failing the test. If you want a different timeout you can define it like this:

{{{
await().atMost(5, SECONDS).until(newUserWasAdded());
}}}

== Example 2 - Better reuse==

Awaitility also supports splitting up the condition into a supplying and a matching part for better reuse. The example above can also be written as:

{{{
await().until( userRepositorySize(), equalTo(1) );
}}}

The `userRepositorySize` method is now a `Callable` of type `Integer`:
{{{
private Callable<Integer> userRepositorySize() {
	return new Callable<Integer>() {
		public Integer call() throws Exception {
			return userRepository.size(); // The condition supplier part
		}
	};
}
}}}

`equalTo` is a standard <a href="http://code.google.com/p/hamcrest/">Hamcrest</a> matcher specifiying the matching part of the condition for Awaitility.

Now we could reuse the `userRepositorySize` in a different test. E.g. let's say we have a test that adds three users at the same time:

{{{
publish(new AddUserMessage("User 1"), new AddUserMessage("User 2"), new AddUserMessage("User 3"));
}}}

We now reuse the `userRepositorySize` supplier and simply update the Hamcrest matcher:
{{{
await().until( userRepositorySize(), equalTo(3) );
}}}

==Example 3 - Proxy based conditions ==
It's also possible to achieve the same result by building up the supplier part using a proxy:

{{{
await().untilCall( to(userRepository).size(), equalTo(3) );
}}}

`to` is method in Awaitility which you can use to define the suppling part inline in the await statement. Thus you don't need to create a `Callable` yourself since it's done for you. Which option you like best depends on the use case and readability.

==Example 4 - Fields == 
You can also build the suppling part by referring to a field. E.g:

{{{
await().until( fieldIn(object).ofType(int.class), equalTo(2) );
}}}

or:

{{{
await().until( fieldIn(object).ofType(int.class).andWithName("fieldName"), equalTo(2) );
}}}

or:

{{{
await().until( fieldIn(object).ofType(int.class).andAnnotatedWith(MyAnnotation.class), equalTo(2) );
}}}


==Example 5 - Advanced==
Use a poll interval of 100 milliseconds with an initial delay of 20 milliseconds until customer status is equal to "REGISTERED". This example also uses a named await by specifying an alias ("customer registration"). This makes it easy to find out which await statement that failed if you have multiple awaits in the same test.
{{{  
with().pollInterval(ONE_HUNDERED_MILLISECONDS).and().with().pollDelay(20, MILLISECONDS).await("customer registration").until(
  		costumerStatus(), equalTo(REGISTERED));
}}}  

= Exception handling =
By default Awaitility catches uncaught exceptions in all threads and propagates them to the awaiting thread. This means that your test-case will indicate failure even if it's not the test-thread that threw the uncaught exception.

= Defaults =
If you don't specify any timeout Awaitility will wait for 10 seconds and then throw a `TimeoutException` if the condition has not been fulfilled. The default poll interval and poll delay is 100 milliseconds. You can also specify the default values yourself using:
  
{{{
  Awaitility.setDefaultTimeout(..)
  Awaitility.setDefaultPollInterval(..)
  Awaitility.setDefaultPollDelay(..)
}}}
  
You can also reset back to the default values using `Awaitility.reset()`.

== Static imports ==
In order to use Awaitility effectively it's recommended to statically import the following methods from the Awaitility framework:
  # `com.jayway.awaitility.Awaitlity.*`
It may also be useful to import these methods:
  # `com.jayway.awaitility.Duration.*`
  # `java.util.concurrent.TimeUnit.*`
  # `org.hamcrest.Matchers.*`
  # `org.junit.Assert.*`


= Polling = 
Awaitility starts to check the specified condition (the one you create using the Awaitility DSL) matches for the first time after a "poll delay" (the initial delay before the polling begins). By default Awaitility uses the same poll delay as poll interval which means that it checks the condition periodically first after the given poll delay, and subsequently with the given poll interval; that is conditions are checked after pollDelay then pollDelay+pollInterval, then pollDelay + 2 pollInterval, and so on. If you change the poll interval the poll delay will also change to match the specified poll interval _unless_ you've specified a poll delay explicitly.
<br/>
Note that since Awaitility uses polling to verify that a condition matches it's not recommended to use it for precise performance testing. In these cases it's better to use an AOP framework such as AspectJ's compile-time weaving.

= Important =
Awaitility does nothing to ensure thread safety or thread synchronization! This is your responsibility! Make sure your code is correctly synchronized or that you are using thread safe data structures such as volatile fields or classes such as AtomicInteger and ConcurrentHashMap. 
 

= Example of usage = 
  # [http://github.com/jayway/awaitility/blob/awaitility-1.2.1/src/test/java/com/jayway/awaitility/AwaitilityTest.java Awaitility test case]